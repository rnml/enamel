* syntax
** universes
   - "Type"                   (implicit level)
   - "Type#0", "Type#1", ...  (explicit level)
** constants
   - upper-case identifiers: List, Cons, Nil, Univalence
   - examples:
     type constructors
     variant constructors
     axioms
** variables
   - lower case identifiers: x, foo, length 
** function type
   - "(X:A) -> B"    (one argument)
   - "(Gamma) -> A"  (multiple arguments)
** function application
   - "\X:A. M"
   - "\(Gamma). M"
** function abstraction
   - "M N"
** inductive type definitions
   - examples
     type Nat : Type =
       | Zero : Nat
       | Succ : Nat -> Nat
     type List (A : Type) : Type =
       | Nil  : List A
       | Cons : A -> List A -> List A
     type Vector (A : Type) : (n : Nat) -> Type =
       | VNil  : Vector A Zero
       | VCons : (n:Nat) -> A -> Vector A n -> Vector A (Succ n)
     type Sum (A : Type, B : A -> Type) : Type =
       | DPair : (x : A) -> B x -> Sum A B
     type Equal (A : Type) : A -> A -> Type =
       | Refl : (x : A) -> Equal A x x
     type DEqual (a : Type) (b : a -> Type) : (x, y: a) -> Equal a x y -> b x -> b y -> Type =
       | DRefl : (u : a) -> (v : b u) -> DEqual u u (Refl a u) v v
     type HEqual (A : Type) (B : Type) : A -> B -> Type =
       | HRefl : (C : Type) -> (x : C) -> HEqual C C x x
     type Circle : Type =
       | Base : Circle
       | Loop : Equal Circle Base Base
     type Sphere : Type =
       | Base : Sphere
       | Surf : Equal (Equal Sphere Base Base) (Refl Sphere Base) (Refl Sphere Base)
** induction principle
   - "induction{Circle}"
